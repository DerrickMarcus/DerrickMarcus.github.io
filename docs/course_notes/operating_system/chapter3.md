# 第3讲 进程的描述与控制

程序顺序执行：计算机系统中只有一个程序在运行，该程序独占系统中的所有资源。一个程序执行完成之后另一个程序才能开始执行。顺序执行是单道批处理系统的执行方式，也用于简单的单片机系统。

程序的并发执行：一定时间内，系统中有两个或两个以上的程序同处于开始运行但尚未结束的状态，并且次序不是事先确定的。引入并发执行的目的是提高资源利用率。主流操作系统均指出并发执行。

并发执行具有特征：间断性（异步性），失去封闭性，失去可再现性。因此并发执行可能会引发一些问题和困难：同步，互斥，作业调度，进程调度，内存管理。

## 1. 进程的定义和描述

进程(Process)是具有独立功能的程序在某个数据集合上的一次运行活动，是系统进行资源分配和调度的独立单位，也称任务(Task)。

进程的特征：动态性，独立性，并发性，异步性，交互性，结构化。

进程的组成：程序 + 数据 + PCB。

进程主要包含的内容：

1. 程序代码，存储于代码段 Text Segment，存储编译后的机器指令、制度的常数变量（如常量字符串）等，该区域只读。低地址。
2. 程序数据，存储于数据段 Data Segment，用于静态内存的分配。其中 `.data` 段存储显式初始化的全局变量和静态变量，`.bss` 段存储未初始化的全局变量和静态变量。地址高于代码段。
3. 堆 Heap，用于动态内存的分配，如 `malloc(), new` 等。先进先出 FIFO。地址高于数据段，且向高地址方向增长。
4. 栈 Stack，保存运行上下文信息，保存函数调用时的局部变量、参数、返回地址等。后进先出 LIFO。地址高于堆，向低地址方向增长。
5. 其他。

!!! note "进程与程序的区别"
    进程是动态的，程序是静态的：程序是有序代码的集合；进程是程序的执行。通常进程不可在计算机之间迁移；而程序通常对应着文件、静态和可以复制。

    进程是暂时的，程序的长久的：进程是一个状态变化的过程，程序可长久保存。

    进程与程序的组成不同：进程的组成包括程序、数据和进程控制块(即进程状态信息)。

    进程与程序的对应关系：通过多次执行，一个程序可对应多个进程；通过调用关系，一个进程可包括多个程序。

进程控制块(PCB, process control block)是专门描述和管理进程的数据结构，记录进程的外部特征，描述进程的运动变化过程。PCB 是系统感知进程存在的唯一标志，进程与 PCB 一一对应。

PCB 中的内容：

1. 进程描述信息：
    1. 进程标识符(process ID)，唯一，通常是一个整数
    2. 进程名，通常基于可执行文件名
    3. 用户标识符(user ID)
    4. 进程组(process group)
2. 进程控制信息：
    1. 当前状态
    2. 优先级(priority)
    3. 代码执行入口地址
    4. 程序的外存地址
    5. 运行统计信息(执行时间、页面调度)
    6. 进程间同步和通信
    7. 阻塞原因
3. 资源占用信息：
    1. 虚拟地址空间的现状
    2. 打开文件列表
4. CPU 现场信息：
    1. 寄存器值：通用寄存器、程序计数器 PC、程序状态字 PSW(program status word)，地址包括栈指针
    2. 指向赋予该进程的段/页表的指针

所有 PCB 组织在一起放在内存的固定区域，构成 PCB 表，或称为进程表(process table)。PCB 表的大小决定了系统中最多可同时存在的进程个数，称为系统的并发度。

PCB 表的组织方式：

1. 链接结构：同一状态的进程其 PCB 成一链表，多个状态对应多个不同的链表索引结构，如就绪链表、阻塞链表。
2. 索引结构：同一状态的进程归入一个 index 表(由 index 指向PCB)，多个状态对应多个不同的 index 表，如就绪索引表、阻塞索引表。

进程上下文(context)是对进程执行过程的描述，由进程的用户地址空间内容、硬件寄存器内容及与该进程相关的核心数据结构组成。

1. 用户及上下文：进程的用户地址空间(包括用户栈各层次)，包括用户正文段、用户数据段和用户栈；
2. 寄存器级上下文：程序寄存器、处理机状态寄存器、栈指针、通用寄存器的值；
3. 系统级上下文：PCB 和资源表格，核心栈(进程在调用系统核心过程时需要)。

OS 内核不是一个进程，其执行不被调度。现代的 Windows 和 Linux 中 OS功能分别在核心和系统服务进程中，只有 OS 核心作为进程地址空间的一部分。

## 2. 进程的状态

进程的3种基本状态：运行，就绪，阻塞。

1. 运行(Running)：进程占有 CPU，正在 CPU 上执行。运行态的进程数一定小于等于 CPU 数目。
2. 就绪(Ready)：进程具备运行条件，但由于 CPU 正在被其他进程占用，暂时不能运行。但是要分配给它 CPU 就能立即运行(万事俱备只欠东风)。
3. 阻塞(Blocked)：进程由于等待某些事件的发生而不能运行。即使 CPU 空闲也不能运行。

4种状态转换：

1. 运行 → 阻塞：当进程必须等待如下事件时：
    1. 对一资源的访问尚不能进行。
    2. 初始化 I/O 且必须等待结果。因为对于高速的 CPU 而言，I/O 操作速度太慢。
    3. 等待某一进程提供输入(IPC)。
2. 运行 → 就绪：运行进程用完了时间片，或另一高优先级进程进入就绪状态，运行进程被中断。
3. 就绪 → 运行：调度程序选择该进程运行。
4. 阻塞 → 就绪：进程所等待的事件发生。

![ch3_img1](https://cdn.jsdelivr.net/gh/DerrickMarcus/picgo_image/images/os_ch3_img1.png)

如果一个进程不涉及 I/O 操作和与其他进程的同步关系，那么它会在运行状态和就绪状态之间循环转换。

一般我们认为不存在另外两种情况。“就绪 → 阻塞”不可能发生，某些 OS 可能存在“阻塞 → 运行”。

!!! warning
    五状态进程模型（加入“新建”和“终止”）、七状态进程模型（进一步加入“就绪挂起”和“阻塞挂起”）不做要求。

## 3. 进程控制

进程控制主要体现在进程的创建与撤销，阻塞与唤醒，挂起与激活。进程控制由具有特定功能的**原语**完成。

原语(primitive)：由若干条指令构成的“原子操作(atomic operation)”过程，作为一个整体而不可分割——要么全都完成，要么全都不做。许多系统调用是原语，但并非所有系统调用都是原语。

创建原语：进程创建的原因。用于系统初始化、执行一个创建进程的系统调用、用户请求创建一个新进程、批处理作业的初始化。进程的存在以 PCB 为标志，所以创建新进程的主要任务就是为进程建立 PCB，将调用者提供的有关信息填入 PCB 的各数据项中。

撤销原语：进程撤销的原因。用于进程的正常退出（自愿）、出错退出（自愿）、发生严重错误（非自愿）、被其他进程杀死（非自愿）。进程终止之后，系统应及时回收它占有的资源。

阻塞原语：实现进程从运行状态 到 阻塞状态的转换。

唤醒原语：实现进程从阻塞状态 到 就绪状态的转换。

挂起原语：实现进程从“阻塞或就绪”状态 到 “阻塞挂起或就绪挂起”状态的转换。

激活原语：实现进程从“阻塞挂起或就绪挂起” 到 “阻塞或就绪”状态的转换。

## 4. Linux 和 Windows 的进程

略。
