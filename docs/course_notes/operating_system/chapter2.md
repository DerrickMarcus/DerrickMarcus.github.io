# 第2讲 绪论(2)

## 1. 操作系统的用户接口

### 操作命令接口

操作命令接口是操作系统为用户操作控制计算机工作和提供服务的手段的集合。实现手段包括：

(1) 批处理系统提供的作业控制语言(JCL, Job Control Language)。专为批处理作业用户提供的，也称批处理用户接口，是一种**脱机用户接口**。

JCL 由一组作业控制卡片，或作业控制语句，或作业控制操作命令组成。用户使用 JCL 语句，把运行意图（需要对作业进行的控制）写在作业说明书上，将作业连同作业说明书一起提交给系统。批处理操作系统时代，用户采用脱机方式使用计算机，即用户将自己的程序、数据和用 JCL 编写的描述上机操作步骤的程序一起提交给计算中心，隔一段时间去机房取结果。

(2) 交互式系统的操作控制命令。由一组命令及命令解释程序组成，是一种**联机用户接口**。工作方式为：用户在键盘上键入一条命令后，系统立即转入命令解释程序，对该命令进行处理和执行。用户界面包括字符显示用户界面、图形化用户界面。

字符显示用户界面中，又有命令行方式和脚本方式两种方式。命令行方式以命令为基本单位，形如 `command arg1 arg2 ...` 。脚本方式相当于将一系列命令放在一个文件中，可多次执行，例如 Windows 的批处理文件 `.bat` 和 Linux 的 shell 脚本。

---

命令解释程序(cmd, PowerShell, bash, zsh, ...)用于接受和执行用户输入的命令。包含内部命令和外部命令。内部命令实际上是命令解释程序的一部分，包含的是一些比较简单的系统命令，由命令解释程序识别并在内部完成运行，系统加载时内部命令随命令解释程序加载并驻留在系统内存中。外部命令不随系统一起加载到内存中，而是在需要时才将其调进内存。通常外部命令的实体并不包含在命令解释程序中，但是其命令执行过程是由命令解释程序控制的。命令解释程序负责管理外部命令执行的路径查找、加载存放，并控制命令的执行。

命令解释程序的处理过程：

1. 系统启动命令解释程序，输出命令提示符，等待键盘中断。用户打入命令并按回车换行，申请键盘中断。
2. CPU响应后，控制权交给命令解释程序，它读入命令缓冲区内容，分析命令、接受参数。
3. 若为内部命令立即转向命令处理代码执行。否则查找命令处理文件，装入主存，传递参数，将控制权交给其执行。
4. 命令处理结束后，再次输出命令提示符，等待下一条命令。

---

图形用户接口GUI(Graphics User Interface)使用 WIMP 界面，即窗口(Window)、图标(Icon)、菜单(Menu)和指点设备(Pointing Device)等技术，将系统的功能、各种应用程序和文件用图形符号直观、逼真地表示出来，用户可通过选择窗口、菜单、对话框和滚动条完成对它们的作业的各种控制和操作。

### 系统调用接口

操作系统和用户程序之间的接口是通过操作系统提供的一套系统调用(System Call)来定义，也称为系统服务(System Service)。对应用程序而言，操作系统内核的作用体现为可以供其调用的一组函数。

系统调用的作用：

1. 为了管理硬件资源和为应用程序开发人员提供良好的环境，同时使应用程序具有更好的兼容性。
2. 为了安全问题，一些 I/O 操作的指令都被限制在只有内核模式可以执行，因此操作系统有必要为应用程序提供访问硬件设备的接口。

系统调用的处理过程：传递系统调用参数 → 执行陷入指令 → 进入核心态 → 执行系统调用处理程序 → 返回用户态。

(1) 有一个类似于硬件中断处理的处理机构，当用户使用系统调用时，使系统进入核心态。为使 CPU 能够主动进入核心态，每种机器的指令集都提供了陷入(Trap)指令，这个指令能够将系统转入核心态。**系统调用由陷入指令实现**。系统调用是操作系统提供给编程人员的唯一接口，利用系统调用，可以动态请求和释放系统资源，完成与硬件相关的工作以及控制程序的执行等。

(2) 为实现系统调用功能的内核函数（子程序）编造入口地址表。陷入处理机构把陷入指令包含的功能号与入口地址表的有关项对应，系统调用功能号驱动有关内核函数的执行。在系统调用结束之后，用户程序需利用系统调用返回结果继续执行。

(3) 保护现场。进入系统调用处理前，陷入处理机构需保存处理机现场；在系统调用处理结束之后，要恢复处理机现场，现场被保护在特定的内存区或寄存器中。

(4) 系统调用是用户程序进入内核的接口层，它本身并非内核函数，但由内核函数实现。进入内核后，不同的系统调用会找到各自对应的内核函数，这些内核函数也被称为系统调用的服务例程。例如 Linux 的系统调用 `getpid` 实际调用的服务例程为 `sys_getpid()` 。

系统调用的封装：陷入指令是一条特殊指令，依赖操作系统实现的平台，移植性差。因此标准 C 库函数为每个系统调用设置封装例程（库函数），用户程序通过调用 C 函数库中相对应的封装例程就能执行系统调用。

---

POSIX：可移植操作系统接口 Portable Operating System Interface。POSIX 定义一套跨操作系统的通用接口标准，确保软件在不同系统上的可移植性。它仅定义接口功能，但不规定实现方式，这些接口可以是系统调用，也可以是库函数，甚至是用户态模拟。例如 POSIX 定义的 `fork()` 功能是“创建子进程”，在 Linux 中对应系统调用 `sys_fork()` ，而在 Windows 中需通过 `CreateProcess()` 等多个 API 组合实现，无直接对应的系统调用。

其过程调用 Call 包括 `fork(), waitpid(), open(), write(), mkdir(), kill()` 等。UNIX 和 Windows 都支持 POSIX 标准。POSIX 标准单义了构造系统所必须提供的一套过程，但是并没有规定它们是系统调用还是普通的库函数调用或者其他形式，因此 POSIX 过程调用映射到系统调用并不是一一对应的。

Windows API/Win32 API：为方便用户编程，Windows 以 DLL 的形式提供了 API(Application Programming Interface 应用程序编程接口)，用户可以通过调用 API 函数来使用 Windows 操作系统的系统调用。API 调用与系统调用也不存在一一对应的关系。

## 2. 操作系统的设计与实现

机制与策略的分离：机制(mechanism)——实现某一功能的具体执行机构；策略(policy)——如何使用这些功能。

例如：“定时器”是一种确保 CPU 保护的机制，“对于特定用户将定时器设置成多长时间”是策略；“操作系统内核实现基于优先级的调度”是机制，“决定 I/O 密集型程序是否比 CPU 密集型程序优先级高”是策略。

|          |                       机制 (Mechanism)                       |                        策略 (Policy)                         |
| :------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|   本质   |               实现功能的底层逻辑/具体手段(HOW)               |                  决策功能的规则/目标(WHAT)                   |
|   举例   | “进程调度”中，保存/恢复进程上下文的代码、切换 CPU 寄存器的逻辑 |     “进程调度”中，优先调度短进程、还是高优先级进程的规则     |
|   特点   |    稳定、通用，不随需求频繁变动；通常与硬件/内核紧密关联     | 灵活、可变，随业务场景/需求调整；通常与资源分配、用户需求绑定 |
| 依赖关系 |           机制是策略的执行基础，策略需通过机制落地           |    策略是机制的应用方向，机制需配合策略决策“何时/如何用”     |

评估效率的常用指标：

1. 吞吐量：单位时间内成功完成的作业（进程数）。
2. 各种资源的使用效率：有效提供提供服务的时间占总工作时间的百分比。
3. 分时系统的响应时间：用户发出请求到系统做出响应的时间。
4. 批处理的作业周转时间：作业进入系统到其完成并退出系统所经历的时间。

## 3. 操作系统体系结构

常见的操作系统体系结构：单体系统、分层系统、虚拟机结构、微内核结构、客户-服务器模式、面向对象的操作系统。

### 单体系统

也称为单一内核结构或模块组合结构。整个系统按功能进行设计和模块划分。系统是一个单一的、庞大的的软件系统，由众多服务过程（模块）组成，可以随意调用其他模块中的服务过程。

优点：具有一定灵活性，模块之间转接的灵活性使运行高效率；结构紧密，接口简单直接。

缺点：功能划分和模块接口难保正确和合理；模块之间的依赖关系（功能调用关系）复杂（调用深度和方向）。

例如：MS-DOS，早期 UNIX。

### 分层系统

把操作系统的所有功能模块按功能的调用次序，分别排列成若干层，各层之间的模块只能是单向依赖或单向调用的关系。每层建立在较低层之上，每层只能利用较低层的功能和服务。

分层的原则：

1. 被调用功能在低层：如文件系统管理、设备管理、设备驱动程序。
2. 活跃功能在低层：提高运行效率。
3. 资源管理的公用模块放在低层：如缓冲区队列、堆栈操作。
4. 最低层的硬件抽象层：与机器特点紧密相关的软件放在最低层。
5. 资源分配策略放在高层，便于修改或适应不同环境。

优点：功能明确，调用关系清晰（高层对低层单向依赖），有利于保证设计和实现的正确性。低层和高层可分别实现（便于扩充），高层错误不会影响到低层。便于修改、扩充，很容易增加或替换掉一层而不影响其它层次。

缺点：效率低，每层为系统调用增加了额外开销(参数或数据的修改与传递)。

例如：1968年 E.W.Dijkstra 开发的 THE 系统。

### 虚拟机结构

通过某种技术，使物理计算机作为共享资源从而创建虚拟机。虚拟机提供了与基本硬件相同的接口。

通过利用 CPU 调度和虚拟内存技术，操作系统能创建一种幻觉，以至于进程认为有自己的处理器和自己的内存。每台虚拟机都与裸机相同，所以每台虚拟机可以运行一台裸机所能够运行的任何类型的操作系统。不同的虚拟机可以运行不同的操作系统。

IBM VM/370，VM/370 的虚拟机监控程序也称为1型超级监控程序(type 1 hypervisor)。

2型超级监控程序(type 2 hypervisor)作为一个应用程序运行在主机操作系统上。2型超级监控程序启动后，可以在虚拟磁盘上安装客户操作系统。虚拟磁盘实际上是主机操作系统中的大文件。客户操作系统在运行时，2型超级监控程序一块块地翻译客户操作系统的二进制程序，将特定的控制指令替换成超级监控程序调用。典型代表：VMWare。

优点：

1. 每个虚拟机完全与其他虚拟机相隔离，由于各种系统资源完全被保护，所以不存在安全问题。
2. 没有直接资源共享。
3. 虚拟机系统是用于研究和开发操作系统的良好工具，虚拟机允许进行系统开发而不必中断正常的系统操作。利用虚拟机，系统开发可在虚拟机而不是真实的物理机器上进行。

### 微内核

微内核结构的思想是：为了实现高可靠性，从操作系统中去掉尽可能多的东西，而只留一个最小的核心运行在核心态下，其他模块作为普通用户进行运行在用户态下。

微内核：运行在核心态的内核提供最基本的操作系统功能，包括中断处理、处理机调度、进程间通信。这些部分只提供了一个很小的功能集合。

服务进程：其它的 OS 服务都是由运行在用户模式下的进程完成，可作为独立的应用进程，称为服务进程。这些模块中的错误不会使整个操作系统崩溃。

优点：

1. 体现机制与策略分离。
2. 良好的扩充性：只需添加支持新功能的服务进程即可。而且所有新服务被增加到用户空间中，不需要修改内核。
3. 可靠性好：所有服务器以用户进程的形式运行，而不是运行在核心态，所以它们不直接访问硬件。假如在文件服务器中发生错误，文件服务器可能崩溃，但不会导致整个系统的崩溃。

缺点：消息传递比直接调用效率要低一些。

例如：MINIX 3 系统，早期 Windows NT。

### 客户-服务器模型

微内核结构的变体，将进程分为两类：服务器（提供某种服务）、客户（使用这些服务）。系统最底层是微内核。

服务器进程和客户进程之间使用消息进行通信。服务器和客户进程可以在相同机器上运行（单机系统），也可以在不同机器上运行（网络系统）。
